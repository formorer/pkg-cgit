From: Nicolas Dandrimont <nicolas.dandrimont@crans.org>
Date: Thu, 31 Jul 2014 20:30:03 +0200
Subject: Return a proper status code when there is no repository found

---
 tests/t0112-no-repo-found.sh | 10 +++++++++
 ui-repolist.c                | 51 +++++++++++++++++++++++++++++++++-----------
 2 files changed, 48 insertions(+), 13 deletions(-)
 create mode 100755 tests/t0112-no-repo-found.sh

diff --git a/tests/t0112-no-repo-found.sh b/tests/t0112-no-repo-found.sh
new file mode 100755
index 0000000..211aa61
--- /dev/null
+++ b/tests/t0112-no-repo-found.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+test_description='Check index page when trying a non-existing repo'
+. ./setup.sh
+
+test_expect_success 'generate index page' 'cgit_url "/no-repo-there" >tmp'
+test_expect_success 'verify "No repositories found" message' 'grep "No repositories found" tmp'
+test_expect_success 'verify status code is 404' 'head -1 tmp | grep "Status: 404"'
+test_expect_success 'verify there is no tree link' '! grep /tree/ tmp'
+test_expect_success 'verify there is no log link' '! grep /log/ tmp'
+
+test_done
diff --git a/ui-repolist.c b/ui-repolist.c
index c2bcce1..29b1f3f 100644
--- a/ui-repolist.c
+++ b/ui-repolist.c
@@ -248,17 +248,44 @@ static int sort_repolist(char *field)
 
 void cgit_print_repolist()
 {
-	int i, columns = 3, hits = 0, header = 0;
+	int i, columns = 3, hits = 0, header = 0, found_repos = 0, matched_size = 0;
 	char *last_section = NULL;
 	char *section;
 	int sorted = 0;
+	struct cgit_repo *repo = NULL;
+	struct cgit_repo **matched_repos = NULL;
 
 	if (ctx.cfg.enable_index_links)
 		++columns;
 	if (ctx.cfg.enable_index_owner)
 		++columns;
 
+	if (ctx.qry.sort)
+		sorted = sort_repolist(ctx.qry.sort);
+	else if (ctx.cfg.section_sort)
+		sort_repolist("section");
+
+	for (i = 0; i < cgit_repolist.count; i++) {
+		repo = &cgit_repolist.repos[i];
+		if (!(is_match(repo) && is_in_url(repo)))
+			continue;
+		if (++found_repos > matched_size) {
+			if (matched_size == 0)
+				matched_size = 8;
+			else
+				matched_size *= 2;
+			matched_repos = xrealloc(matched_repos,
+						 matched_size *
+						 sizeof(struct cgit_repo *));
+		}
+		matched_repos[found_repos-1] = repo;
+	}
+
 	ctx.page.title = ctx.cfg.root_title;
+
+	if (!found_repos)
+		ctx.page.status = 404;
+
 	cgit_print_http_headers();
 	cgit_print_docstart();
 	cgit_print_pageheader();
@@ -266,17 +293,14 @@ void cgit_print_repolist()
 	if (ctx.cfg.index_header)
 		html_include(ctx.cfg.index_header);
 
-	if (ctx.qry.sort)
-		sorted = sort_repolist(ctx.qry.sort);
-	else if (ctx.cfg.section_sort)
-		sort_repolist("section");
+	if (!found_repos) {
+		cgit_print_error("No repositories found");
+		goto docend;
+	}
 
 	html("<table summary='repository list' class='list nowrap'>");
-	for (i = 0; i < cgit_repolist.count; i++) {
-		ctx.repo = &cgit_repolist.repos[i];
-		if (!(is_match(ctx.repo) && is_in_url(ctx.repo)))
-			continue;
-		hits++;
+	for (hits = 1; hits <= found_repos; hits++) {
+		ctx.repo = matched_repos[hits-1];
 		if (hits <= ctx.qry.ofs)
 			continue;
 		if (hits > ctx.qry.ofs + ctx.cfg.max_repo_count)
@@ -328,11 +352,12 @@ void cgit_print_repolist()
 		html("</tr>\n");
 	}
 	html("</table>");
-	if (!hits)
-		cgit_print_error("No repositories found");
-	else if (hits > ctx.cfg.max_repo_count)
+	if (hits > ctx.cfg.max_repo_count)
 		print_pager(hits, ctx.cfg.max_repo_count, ctx.qry.search, ctx.qry.sort);
+
+docend:
 	cgit_print_docend();
+	free(matched_repos);
 }
 
 void cgit_print_site_readme()
